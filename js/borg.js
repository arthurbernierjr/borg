// Generated by CoffeeScript 1.4.0
var Debugger, host, match, nil, node, pass, pkg, ssh, user, _i, _len, _ref;

Debugger = (function() {

  function Debugger() {}

  Debugger.started = new Date;

  Debugger.log = function(s) {
    var current;
    if (typeof console !== "undefined" && console !== null) {
      current = new Date;
      return console.log("[" + ((current - this.started) / 1000) + "s] " + s);
    }
  };

  return Debugger;

})();

switch (process.argv[2]) {
  case '-V':
  case '--version':
  case 'version':
    pkg = require('../package.json');
    console.log("borg v" + pkg.version + " - by Mike Smullin <mike@smullindesign.com>\n");
    break;
  case '-h':
  case '--help':
  case 'help':
    switch (process.argv[3]) {
      case 'rekey':
        console.log("Usage: borg rekey [options] <user:password@host ...>\n\nOptions:\n\n  -i  identity file path\n");
        break;
      case 'ssh':
        console.log('');
        break;
      case 'deploy':
        console.log('');
        break;
      default:
        console.log("Usage: borg <command> [options] <host ...>\n\nCommands:\n\n  rekey   copy ssh public key to authorized_hosts on remote host(s)\n  ssh     bulk execute command on remote host(s)\n  deploy  execute cookbook on remote host(s)\n\nOptions:\n\n  -h, --help     output usage information\n  -V, --version  output version number\n");
    }
    break;
  case 'rekey':
    console.log(process.argv.slice(3));
    _ref = process.argv.slice(3);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!(match = node.match(/^(.+?)(:(.+))?@(.+)$/))) {
        continue;
      }
      nil = match[0], user = match[1], nil = match[2], pass = match[3], host = match[4];
      console.log('trying');
      ssh = new (require('ssh2'));
      ssh.on('connect', function() {
        return Debugger.log('connected');
      });
      ssh.on('ready', function() {
        Debugger.log('ready');
        return ssh.exec('date', function(err, stream) {
          if (err) {
            throw err;
          }
          stream.on('data', function(data, extended) {
            return Debugger.log("" + (extended === 'stderr' ? 'stderr' : 'stdout') + ": " + data);
          });
          stream.on('end', function() {
            return Debugger.log('stream EOF');
          });
          stream.on('close', function() {
            return Debugger.log('stream closed');
          });
          return stream.on('exit', function(code, signal) {
            Debugger.log("stream exit code " + code + ", signal " + signal);
            return ssh.end();
          });
        });
      });
      ssh.on('error', function(err) {
        return Debugger.log("Connection error: " + err);
      });
      ssh.on('end', function() {
        return Debugger.log("Connection end");
      });
      ssh.on('close', function() {
        return Debugger.log("Connection closed");
      });
      ssh.connect({
        host: host,
        port: 22,
        username: user,
        password: pass
      });
    }
    break;
  case 'ssh':
    console.log(process.argv.slice(3));
    break;
  case 'deploy':
    console.log(process.argv.slice(3));
}
